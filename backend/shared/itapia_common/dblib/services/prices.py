"""Service layer for price-related operations.\n\nThis module provides high-level interfaces for retrieving and managing price data,\nhandling conversion between raw database/Redis records and Pydantic models.\n"""\n\nfrom datetime import datetime\nfrom typing import List\n\nimport pandas as pd\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import Engine\n\nfrom redis.client import Redis\n\nfrom itapia_common.dblib.crud.prices import get_daily_prices, get_intraday_prices, \\\n    get_latest_intraday_price, get_tickers_by_sector, add_intraday_candle, get_last_history_date\nfrom itapia_common.dblib.crud.general_update import bulk_insert\nfrom itapia_common.schemas.entities.prices import Price, PriceDataPoint\n\nfrom .metadata import APIMetadataService\n\nimport itapia_common.dblib.db_config as dbcfg\n\nfrom itapia_common.logger import ITAPIALogger\n\nlogger = ITAPIALogger('Prices Service of DB')\n\nclass APIPricesService:\n    \"\"\"Service class for API-level price operations.\"\"\"\n    \n    def __init__(self, rdbms_session: Session, redis_client: Redis,\n                 metadata_service: APIMetadataService):\n        \"\"\"Initialize the APIPricesService with database session, Redis client, and metadata service.\n\n        Args:\n            rdbms_session (Session): The SQLAlchemy database session.\n            redis_client (Redis): The Redis client instance.\n            metadata_service (APIMetadataService): The metadata service instance.\n        \"\"\"\n        self.rdbms_session = rdbms_session\n        self.redis_client = redis_client\n        self.metadata_service = metadata_service\n        \n    def get_daily_prices(self, ticker: str, skip: int, limit: int) -> Price:\n        \"\"\"Retrieve and package historical daily price data for a ticker.\n\n        This method fetches daily price data and converts it to Pydantic models\n        with proper timestamp handling.\n\n        Args:\n            ticker (str): The ticker symbol to retrieve price data for.\n            skip (int): Number of records to skip for pagination.\n            limit (int): Maximum number of records to return.\n\n        Returns:\n            Price: A packaged price response with metadata and data points.\n        \"\"\"\n        logger.info(f"SERVICE: Preparing daily prices for ticker {ticker}")\n        metadata = self.metadata_service.get_validate_ticker_info(ticker, 'daily')\n        \n        price_rows = get_daily_prices(self.rdbms_session, dbcfg.DAILY_PRICES_TABLE_NAME,\n                                      ticker, skip, limit)\n        \n        # Convert data to Pydantic objects\n        price_points = [\n            PriceDataPoint(\n                timestamp=int(row['collect_date'].timestamp()), \n                **row\n            ) for row in price_rows\n        ]\n        \n        return Price(metadata=metadata, \n                                datas=price_points)\n        \n    def get_daily_prices_by_sector(self, sector_code: str, skip: int, limit: int) -> List[Price]:\n        \"\"\"Retrieve and package daily price data for all stocks in a sector.\n\n        This method fetches daily price data for all tickers in a sector and\n        converts them to Pydantic models.\n\n        Args:\n            sector_code (str): The sector code to retrieve price data for.\n            skip (int): Number of records to skip for pagination.\n            limit (int): Maximum number of records to return per ticker.\n\n        Returns:\n            List[Price]: A list of packaged price responses for each ticker in the sector.\n        \"\"\"\n        logger.info(f"SERVICE: Preparing daily prices for sector {sector_code}...")\n        \n        # 1. Get list of tickers in this sector\n        tickers_in_sector = get_tickers_by_sector(self.rdbms_session, dbcfg.TICKER_METADATA_TABLE_NAME,\n                                                  sector_code.upper())\n        \n        all_payloads: List[Price] = []\n        \n        if not tickers_in_sector:\n            # Can return empty list or raise error depending on requirements\n            # Returning empty list is usually more client-friendly\n            return all_payloads\n\n        \n        # 2. Loop through each ticker and create payload for it\n        for ticker in tickers_in_sector:\n            try:\n                # --- REUSE EXISTING LOGIC ---\n                # Call the function to get data for a single ticker\n                single_ticker_payload = self.get_daily_prices(\n                    ticker=ticker, \n                    skip=skip, \n                    limit=limit\n                )\n                if single_ticker_payload.datas:  # Only add if price data exists\n                    all_payloads.append(single_ticker_payload)\n            except Exception as e:\n                # Skip tickers with errors and log\n                logger.warn(f"Warning: Could not fetch data for ticker {ticker}. Error: {e}")\n                continue\n                \n        return all_payloads\n    \n    def get_intraday_prices(self, ticker: str, latest_only: bool = False) -> Price:\n        \"\"\"Retrieve and package intraday price data from Redis for a ticker.\n\n        This method fetches intraday price data from Redis and converts it to \n        Pydantic models with proper timestamp handling.\n\n        Args:\n            ticker (str): The ticker symbol to retrieve price data for.\n            latest_only (bool, optional): Whether to retrieve only the latest price data. \n                                        Defaults to False.\n\n        Returns:\n            Price: A packaged price response with metadata and data points.\n\n        Raises:\n            ValueError: If no intraday data is found for the ticker.\n        \"\"\"\n        logger.info(f"SERVICE: Preparing intraday prices for ticker {ticker}")\n        metadata = self.metadata_service.get_validate_ticker_info(ticker, 'intraday')\n\n        if latest_only:\n            price_rows = [get_latest_intraday_price(self.redis_client, ticker.upper(), dbcfg.INTRADAY_STREAM_PREFIX)]\n        else:\n            price_rows = get_intraday_prices(self.redis_client, ticker.upper(), dbcfg.INTRADAY_STREAM_PREFIX)\n            \n        if not price_rows or price_rows[0] is None:\n            raise ValueError(f'Intraday data not found for ticker {ticker}')\n        \n        price_points = [\n            PriceDataPoint(\n                timestamp=int(row['last_update_utc'].timestamp()),\n                **row\n            ) for row in price_rows\n        ]\n        \n        return Price(metadata=metadata,\n                                datas=price_points)\n        \nclass DataPricesService:\n    \"\"\"Service class for data-level price operations.\"\"\"\n    \n    def __init__(self, engine: Engine, redis_client: Redis = None):\n        \"\"\"Initialize the DataPricesService with a database engine and optional Redis client.\n\n        Args:\n            engine (Engine): The SQLAlchemy database engine.\n            redis_client (Redis, optional): The Redis client instance. Defaults to None.\n        \"\"\"\n        self.engine = engine\n        self.redis_client = redis_client\n        \n    def add_daily_prices(self, data: list[dict]|pd.DataFrame,\n                         unique_cols: list[str]):\n        \"\"\"Add daily price data to the database.\n\n        Args:\n            data (list[dict] | pd.DataFrame): Price data to insert.\n            unique_cols (list[str]): List of columns that make up a unique constraint.\n        \"\"\"\n        bulk_insert(self.engine, dbcfg.DAILY_PRICES_TABLE_NAME, data, unique_cols,\n                    chunk_size=2000, on_conflict='update')\n        \n    def add_intraday_prices(self, candle_data: dict,\n                            ticker: str):\n        \"\"\"Add intraday price data to Redis.\n\n        Args:\n            candle_data (dict): Candle data to store in Redis.\n            ticker (str): Ticker symbol to associate with the candle data.\n        \"\"\"\n        add_intraday_candle(self.redis_client, ticker, candle_data, \n                            dbcfg.INTRADAY_STREAM_PREFIX, max_entries=300)\n        \n    def get_last_history_date(self, \n                             tickers: list[str],\n                             default_return_date: datetime) -> datetime:\n        \"\"\"Get the latest history date for a list of tickers.\n\n        Args:\n            tickers (list[str]): List of ticker symbols to check.\n            default_return_date (datetime): Default date to return if no data is found.\n\n        Returns:\n            datetime: The latest history date or the default date.\n        \"\"\"\n        return get_last_history_date(self.engine, dbcfg.DAILY_PRICES_TABLE_NAME, tickers, default_return_date)